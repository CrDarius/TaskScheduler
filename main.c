/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2021 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stdio.h>
#include "main.h"

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif


uint32_t current_task = 0;
uint32_t global_tick_count = 0;
uint32_t* const ICSR = (uint32_t*) 0xE000ED04;



task_t tasks[NO_TASKS];

int main(void)
{
    enable_handlers();
	init_scheduler_stack(START_STACK_SCHEDULER);
	init_tasks();
    init_tasks_psp();
	Init_SysTick_Timer();
	change_sp_to_psp();
	//Task_1_Handler();
	Task_Idle();
	for(;;);
}

void enable_handlers(void)
{
	uint32_t volatile *const pSHCSR = (uint32_t*)0xE000ED24;
	*pSHCSR |= (7 << 16); // enable mem manage, bus fault, usage fault
}

__attribute__((naked)) void init_scheduler_stack(uint32_t sched_top_of_stack)
{
	__asm("MSR MSP, R0");
	__asm("BX LR");
}

void init_tasks(void)
{
	tasks[0].p_psp_task_pointer = START_STACK_IDLE;
	tasks[1].p_psp_task_pointer = START_STACK_TASK1;
	tasks[2].p_psp_task_pointer = START_STACK_TASK2;
	tasks[3].p_psp_task_pointer = START_STACK_TASK3;
	tasks[4].p_psp_task_pointer = START_STACK_TASK4;

	tasks[0].p_task_handler = Task_Idle;
	tasks[1].p_task_handler = Task_1_Handler;
	tasks[2].p_task_handler = Task_2_Handler;
	tasks[3].p_task_handler = Task_3_Handler;
	tasks[4].p_task_handler = Task_4_Handler;

	tasks[0].task_state = TASK_READY_STATE;
	tasks[1].task_state = TASK_READY_STATE;
	tasks[2].task_state = TASK_READY_STATE;
	tasks[3].task_state = TASK_READY_STATE;
	tasks[4].task_state = TASK_READY_STATE;
}

void init_tasks_psp(void)
{

	for (int i = 0; i < NO_TASKS; i++)
	{
		uint32_t* pPSP = (uint32_t*) tasks[i].p_psp_task_pointer;
		//xPSR
		pPSP--;
		*pPSP = 0x01000000;

		//PC
		pPSP--;
		*pPSP =(uint32_t) tasks[i].p_task_handler;

		//LR
		pPSP--;
		*pPSP = 0xFFFFFFFD;

		pPSP = pPSP - 13;
		tasks[i].p_psp_task_pointer = (uint32_t) pPSP;

	}
}

void Init_SysTick_Timer(void)
{
	uint32_t const timerCountValue = CLOCK/SYSTICK_FREQ - 1;
	uint32_t* const sysTickRVR = (uint32_t*)0xE000E014;
	uint32_t* const sysTickCSR = (uint32_t*)0xE000E010;

	//load counter value
	*sysTickRVR = 0x000000;
	*sysTickRVR = timerCountValue;

	//assert systick request
	*sysTickCSR |= (1 << 1);

	//specify clock source
	*sysTickCSR |= (1 << 2);

	//enable counter
	*sysTickCSR |= (1 << 0);

}

__attribute__((naked))void change_sp_to_psp(void)
{
	__asm volatile("MSR PSP, %0"::"r"(tasks[current_task].p_psp_task_pointer));
	//PSP is the current stack pointer
	__asm volatile("MOV R0, #0x02");
	__asm volatile("MSR CONTROL, R0");
	//return
	__asm volatile("BX LR");
}

static inline void interrupt_disable(void)
{
	__asm volatile("MOV R0, #0x01");
	__asm volatile("MSR PRIMASK, R0");
}

static inline void interrupt_enable(void)
{
	__asm volatile("MOV R0, #0x00");
	__asm volatile("MSR PRIMASK, R0");
}

void delay_task(uint32_t delay)
{
	interrupt_disable();
	__asm volatile("MOV R0, #0x01");
	__asm volatile("MSR PRIMASK, R0");
	tasks[current_task].task_local_tick_count = global_tick_count+delay;
	tasks[current_task].task_state = TASK_BLOCK_STATE;
	*ICSR |= (1 << 28);
	//enable interrupts
	interrupt_enable();

}

void Task_Idle(void)
{
	while(1);
}

void Task_1_Handler(void)
{
	while(1)
	{
		delay_task(1000);
	}
}

void Task_2_Handler(void)
{
	while(1)
	{
		delay_task(500);
	}
}

void Task_3_Handler(void)
{
	while(1)
	{
		delay_task(250);
	}
}

void Task_4_Handler(void)
{
	while(1)
	{
		delay_task(125);
	}
}

void switch_task(void)
{
	uint8_t state;
	for(int i = 0; i < NO_TASKS; i++)
	{
		current_task++;
		current_task = current_task % NO_TASKS;
		state = tasks[current_task].task_state;
		if( (state == TASK_READY_STATE) && (current_task) )
		{
			break;
		}
	}

	if(!state)
	{
		current_task = 0;
	}

}

__attribute__((naked))void PendSV_Handler(void)
{
	//Save context of the current task
	//1. Get current running task PSP value
	__asm volatile("MRS R0, PSP");
	//2. Use that PSP to store the 2nd Stack Frame (R4->R11)
	__asm volatile("STMDB R0!, {R4-R11}");
	//3. Save the current value of PSP
	__asm volatile("MOV %0, R0":"=r"(tasks[current_task].p_psp_task_pointer));

	//Retrieve the context of the next task
	__asm volatile("PUSH {LR}");
	//1. Decide the next task
	switch_task();
	
	//2. Get the link register
	__asm volatile("POP {LR}");
	//3. Get its PSP value
	__asm volatile("MOV R0,%0"::"r"(tasks[current_task].p_psp_task_pointer));
	//4. Retrieve 2nd Stack Frame of the task
	__asm volatile("LDMIA R0!, {R4-R11}");
	//5. Update PSP and exit
	__asm volatile("MSR PSP, R0");
	__asm volatile("BX LR");
}

void SysTick_Handler(void)
{
	global_tick_count++;
	for(int i = 1; i < NO_TASKS; i++)
	{
		if(tasks[i].task_state != TASK_READY_STATE)
			if(tasks[i].task_local_tick_count == global_tick_count)
				tasks[i].task_state = TASK_READY_STATE;
	}
	//pend the PendSV
	*ICSR |= (1 << 28);
}

void HardFault_Handler(void)
{
	while(1);
}

void MemManage_Handler(void)
{
	while(1);
}

void BusFault_Handler(void)
{
	while(1);
}

void UsageFault_Handler(void)
{
	while(1);
}
